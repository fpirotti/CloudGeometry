% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculateGeometricFeatures.R
\name{calcGF}
\alias{calcGF}
\title{calcGF}
\usage{
calcGF(pc3d, rk = 1, varRadius = FALSE, progress = T, verbose = F, threads = 0)
}
\arguments{
\item{pc3d}{matrix 3D point cloud in  matrix format with columns
with X Y Z coordinates, #' and rows of observations, so M rows
and 3 columns}

\item{rk}{\strong{(1) in case of varRadius==FALSE}, rk is the radius of the sphere
where  to find the nearest neighbours for each point.

\strong{(2) in case of varRadius==TRUE} rk is the largest number of nearest
neighbours to read from and that define the largest radius - from here 30
smaller radii will be tested to find the one with the minimum eigen entropy
value.
\emph{the varRadius parameter is TRUE}, this is the k nearest neighbours that will
be evaluated for the largest starting radius.}

\item{varRadius}{boolean (default is false) - will use a different heuristic
and will add k-neighbours untile it minimizes the eigenEntropy and fixes the
radius.}

\item{progress}{a logical boolean (default is TRUE) - if true a progress bar
will be shown}

\item{verbose}{a logical boolean (default is FALSE) - if true a
lot of messages will be shown.}

\item{threads}{number of threads. If zero (default) is set, it will use t-2,
i.e. all threads except 2 if machine has more than 4 threads. Only works if
CloudGeometry was build with OpenMP support (see documentation)}
}
\value{
matrix with M rows.

Columns will have  the following geometric features:
\describe{
\item{pointDensity}{Number of neighbours in 3d space of sphere of radius}
\item{eigenValue1}{eigenValue 1 (largest value)}
\item{eigenValue2}{eigenValue 2 (medium value)}
\item{eigenValue3}{eigenValue 3 (smallest value)}
\item{eigenEntropy}{Eigen Entropy: \eqn{- \sum_{i}^{3}\lambda_{i}*ln(\lambda_{i})}
where eigen values are normalized as   \eqn{\lambda_{i}=\frac{e_{i}}{\sum_{i}^{3}e_{i}} } }
\item{eigenSum}{Sum of Eigen values}
\item{PCA1}{First principal component}
\item{PCA2}{Second principal component}
\item{linearity}{Linearity \eqn{\frac{\lambda_{1} - \lambda_{2} }{\lambda_{1}} }  }
\item{planarity}{Planarity \eqn{\frac{\lambda_{2} - \lambda_{3} }{\lambda_{1}} }  }
\item{sphericity}{Sphericity  \eqn{\frac{\lambda_{3}}{\lambda_{1}} } }
\item{verticality}{ Angle of normal vector of best fit plane from the vertical normal vector. }
\item{anisotropy}{  Anisotropy \eqn{\frac{\lambda_{1} - \lambda_{3} }{\lambda_{1}} }  }
\item{omnivariance}{ Omnivariance \eqn{\sqrt[3]{\lambda_1\lambda_2\lambda_3 }}. }
\item{change_of_curvature}{ Also called surface variation:
\eqn{\frac{e_{3}}{\sum_{i}^{3}e_{i}} }  . }
\item{optRadius}{ Only available if "\strong{varRadius=TRUE}" and shows the optimal radius value that minimizes the entropy of eigen values. }

}
}
\description{
Calculate Geometric Features
}
\examples{
#subset the first 100 rows of the lidar point cloud example to limit execution time.
#nn <- calcGF(lidar,5, FALSE, TRUE, TRUE)
# ## bind to original table
# data.table::fwrite( cbind(lidar, nn), "out.csv")

}
